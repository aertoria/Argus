/* Generated By:JavaCC: Do not edit this line. AnnotationReader.java */
/* Copyright (c) 2014, Salesforce.com, Inc.
 * All rights reserved.
 *  
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *   
 *      Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 *      Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *      Neither the name of Salesforce.com nor the names of its contributors may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

package com.salesforce.dva.argus.service.annotation;

import com.salesforce.dva.argus.entity.Annotation;
import java.io.*;
import java.util.*;
import com.salesforce.dva.argus.service.TSDBService;
import com.salesforce.dva.argus.service.tsdb.AnnotationQuery;
import com.salesforce.dva.argus.system.SystemException;
import static com.salesforce.dva.argus.system.SystemAssert.*;

public class AnnotationReader<T> implements AnnotationReaderConstants {

        private TSDBService tsdbService;

    AnnotationReader(TSDBService tsdbService) {
        this((Reader)null);
        this.tsdbService = tsdbService;
    }

    public static boolean isValid(Collection<String> expressions) {
        boolean result = true;
        if(expressions != null) {
            AnnotationReader reader = new AnnotationReader((TSDBService)null);
            for(String expression : expressions) {
                try {
                    if(!reader.isValidExpression(expression)) {
                        result = false;
                        break;
                    }
                } catch (Exception ex) {
                    result = false;
                    break;
                }
            }
        }
        return result;
    }

    public static boolean isValid(String expression) {
        return isValid(Arrays.asList(new String[] {expression}));
    }

        enum TimeUnit {

        SECOND("s", 1000),
        MINUTE("m", 60 * SECOND.getValue()),
        HOUR("h", 60 * MINUTE.getValue()),
        DAY("d", 24 * HOUR.getValue());

        private final String _unit;
        private final long _value;

        private TimeUnit(String unit, long value) {
            _unit = unit;
            _value = value;
        }

        public String getUnit() {
            return _unit;
        }

        public long getValue() {
            return _value;
        }

        public static TimeUnit fromString(String text) {
                        if (text != null) {
                                for (TimeUnit unit : TimeUnit.values()) {
                                        if (text.equalsIgnoreCase(unit.getUnit())) {
                                                return unit;
                                        }
                                }
                        }
                        throw new SystemException(text + ": This time unit is not supported.", new UnsupportedOperationException());
        }
    }

  final public boolean isValidExpression(String expression) throws ParseException {
                {if (true) return start(expression, true, (Class<T>) Annotation.class) != null;}
    throw new Error("Missing return statement in function");
  }

  final public List<T> parse(String expression, Class<T> clazz) throws ParseException {
                {if (true) return start(expression, false, clazz);}
    throw new Error("Missing return statement in function");
  }

  final private List<T> start(String expression, boolean syntaxOnly, Class<T> clazz) throws ParseException {
        List<T> result;
        requireState(syntaxOnly || tsdbService != null, "TSDB service can only be null when only syntax validation is being performed.");
        ReInit(new StringReader(expression));
    result = expression(syntaxOnly, clazz);
    jj_consume_token(0);
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final private List<T> expression(boolean syntaxOnly, Class<T> clazz) throws ParseException {
        Long startTimestamp = null;
        Long endTimestamp = null;
        String scope = null;
        String metric = null;
    String type = null;
    String user = null;
        Map<String, String> tags = new HashMap<String, String>();
    startTimestamp = getTime();
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIME:
      endTimestamp = getTime();
      jj_consume_token(COLON);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    scope = getString();
    jj_consume_token(COLON);
    metric = getString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_CURLY:
      jj_consume_token(LEFT_CURLY);
      tags = getTags();
      jj_consume_token(RIGHT_CURLY);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    type = getString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      user = getString();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
                if(AnnotationQuery.class.equals(clazz)) {
                        AnnotationQuery query = new AnnotationQuery(scope, metric, tags, type, startTimestamp, endTimestamp);
            List<AnnotationQuery> queries = new ArrayList<AnnotationQuery>();
            queries.add(query);
            {if (true) return (List<T>) queries;}
                } else if(Annotation.class.equals(clazz)) {
                        if(syntaxOnly) {
                    {if (true) return (List<T>) new ArrayList<Annotation>(0);}
                } else {
                    AnnotationQuery query = new AnnotationQuery(scope, metric, tags, type, startTimestamp, endTimestamp);
                    List<AnnotationQuery> queries = new ArrayList<AnnotationQuery>();
                    queries.add(query);
                    List<Annotation> annotations = tsdbService.getAnnotations(queries);
                    if(user == null) {
                        {if (true) return (List<T>) annotations;}
                    } else {
                        List<Annotation> filtered = new ArrayList<Annotation>(annotations.size());
                        for(Annotation annotation : annotations) {
                            Map<String,String> fields = annotation.getFields();
                            if(user.equals(fields.get("user")) || fields.get("user") == null) {
                                filtered.add(annotation);
                            }
                        }
                        {if (true) return (List<T>) filtered;}
                    }
                }
                } else {
                        {if (true) throw new IllegalArgumentException("Invalid class type: " + clazz);}
                }
    throw new Error("Missing return statement in function");
  }

  final private Long getTime() throws ParseException {
        Token t = null;
        Token t1 = null;
    t = jj_consume_token(TIME);
                try
                {
                        String timeStr = t.image;
                        if(timeStr.charAt(0) == '-') {
                                String timeDigits = timeStr.substring(1, timeStr.length() - 1);
                                String timeUnit = timeStr.substring(timeStr.length() - 1);
                                Long time = Long.parseLong(timeDigits);
                                TimeUnit unit = TimeUnit.fromString(timeUnit);
                                {if (true) return (System.currentTimeMillis() - (time * unit.getValue())) / 1000 * 1000;}
                        }
                        {if (true) return Long.parseLong(timeStr);}
                } catch(NumberFormatException nfe) {
                        {if (true) throw new SystemException("Could not parse time.", nfe);}
                }
    throw new Error("Missing return statement in function");
  }

  final private String getString() throws ParseException {
        Token t = null;
    t = jj_consume_token(TSDB_ALLOWED_TEXT);
          {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final private Map<String, String> getTags() throws ParseException {
        Token t = null;
    t = jj_consume_token(TAGS);
                Map<String, String> tagsMap = new HashMap<String, String>();
                String tagsStr = t.image;
                String[] tags = tagsStr.split(",");
                for(String tag : tags) {
                        String[] tagKVPair = tag.split("=");
                        String tagK = tagKVPair[0];
                        String tagV = tagKVPair[1];
                        tagsMap.put(tagK, tagV);
                }
                {if (true) return tagsMap;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public AnnotationReaderTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[3];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2000,0x100,0x20,};
   }

  /** Constructor with InputStream. */
  public AnnotationReader(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AnnotationReader(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AnnotationReaderTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public AnnotationReader(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnnotationReaderTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public AnnotationReader(AnnotationReaderTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AnnotationReaderTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[17];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 3; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 17; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
